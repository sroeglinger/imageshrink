
#include <stdlib.h>
#include <iostream>
#include <fstream>      // std::ifstream
#include <limits>       // std::numeric_limits<...>::...

#include <turbojpeg.h>



int main( int argc, const char* argv[] )
{
    int tjRet = 0;
    const int COLOR_COMPONENTS = 3;

    // open file
    std::ifstream ifs( "/home/wast/Documents/test/test/resources/lena.jpg", std::ifstream::in | std::ifstream::binary );

    // determine size of file
    ifs.ignore( std::numeric_limits<std::streamsize>::max() );
    std::streamsize length = ifs.gcount();
    ifs.clear();   //  Since ignore will have set eof.
    ifs.seekg( 0, std::ios_base::beg );

    const long unsigned int _jpegSize = length;

    // read file
    unsigned char* _compressedImage = new unsigned char[_jpegSize];
    ifs.read( reinterpret_cast<char*>(_compressedImage), length );
    ifs.close();
    
    
    // decompress jpeg
    tjhandle _jpegDecompressor = tjInitDecompress();

    int jpegSubsamp, width, height, jpegColorspace;
    tjRet = tjDecompressHeader3(
        _jpegDecompressor,
        _compressedImage,
        _jpegSize,
        &width,
        &height,
        &jpegSubsamp,
        &jpegColorspace
    );

    std::cout << "tjDecompressHeader3" << std::endl;
    std::cout << "tjRet: " << tjRet << std::endl;
    if( tjRet != 0 )
    {
        std::cout << "tjGetErrorStr(): " <<  tjGetErrorStr() << std::endl;
    }
    else
    {
        std::cout << "width:  " <<  width << std::endl;
        std::cout << "height: " <<  height << std::endl;

        switch( jpegSubsamp )
        {
            case TJSAMP_444:  std::cout << "chrominance subsampling: 4:4:4" << std::endl;     break;
            case TJSAMP_422:  std::cout << "chrominance subsampling: 4:2:2" << std::endl;     break;
            case TJSAMP_420:  std::cout << "chrominance subsampling: 4:2:0" << std::endl;     break;
            case TJSAMP_GRAY: std::cout << "chrominance subsampling: Grayscale" << std::endl; break;
            case TJSAMP_440:  std::cout << "chrominance subsampling: 4:4:0" << std::endl;     break;
            case TJSAMP_411:  std::cout << "chrominance subsampling: 4:1:1" << std::endl;     break;
            default:          std::cout << "chrominance subsampling: ?" << std::endl;         break;
        }

        switch( jpegColorspace )
        {
            case TJCS_RGB:   std::cout << "colorspace: RGB" << std::endl;                   break;
            case TJCS_YCbCr: std::cout << "colorspace: YCbCr" << std::endl;                 break;
            case TJCS_GRAY:  std::cout << "colorspace: Grayscale" << std::endl;             break;
            case TJCS_CMYK:  std::cout << "colorspace: CMYK" << std::endl;                  break;
            case TJCS_YCCK:  std::cout << "colorspace: YCCK (aka \"YCbCrK\")" << std::endl; break;
            default:         std::cout << "colorspace: ?" << std::endl;                     break;
        }
    }

    unsigned char* _imageBuffer = new unsigned char[width * height * COLOR_COMPONENTS]; //!< will contain the decompressed image

    tjRet = tjDecompress2(
        _jpegDecompressor, 
        _compressedImage, 
        _jpegSize, 
        _imageBuffer, 
        width, 
        0/*pitch*/, 
        height, 
        TJPF_RGB, 
        TJFLAG_FASTDCT
    );

    std::cout << "tjDecompress2" << std::endl;
    std::cout << "tjRet: " << tjRet << std::endl;
    if( tjRet != 0 )
    {
        std::cout << "tjGetErrorStr(): " <<  tjGetErrorStr() << std::endl;
    }

    tjDestroy(_jpegDecompressor);




    // compress jpeg
    tjhandle _jpegCompressor = tjInitCompress();

    long unsigned int _jpegSize2 = tjBufSize( width, height, jpegSubsamp );
    unsigned char* _compressedImage2 = tjAlloc( _jpegSize2 );
    // long unsigned int _jpegSize2 = 0;
    // unsigned char* _compressedImage2 = NULL;
    tjRet = tjCompress2(
        _jpegCompressor, 
        _imageBuffer, 
        width, 
        /*pitch*/ 0, 
        height, 
        TJPF_RGB, 
        &_compressedImage2, 
        &_jpegSize2, 
        TJSAMP_444, 
        /*JPEG_QUALITY*/10, 
        TJFLAG_FASTDCT
    );

    std::cout << "tjCompress2" << std::endl;
    std::cout << "tjRet: " << tjRet << std::endl;
    if( tjRet != 0 )
    {
        std::cout << "tjGetErrorStr(): " <<  tjGetErrorStr() << std::endl;
    }


    tjDestroy(_jpegCompressor);



    // write new image
    std::ofstream ofs ( "lena_new.jpg", std::ifstream::out | std::wifstream::binary );
    ofs.write( reinterpret_cast<const char*>(_compressedImage2), _jpegSize2 );
    ofs.close();




    //to free the memory allocated by TurboJPEG (either by tjAlloc(), 
    //or by the Compress/Decompress) after you are done working on it:
    tjFree( _compressedImage2 );


    delete[] _compressedImage;

    std::cout << "... done" << std::endl;

    return EXIT_SUCCESS;
}
